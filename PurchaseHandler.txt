(ModuleScript)
Handles the processes that happen when the player tries to purchase something
------------------------------------------------------------------------------------------------------------------------------------------------

local Objects = {}
local TeamColor = script.Parent:WaitForChild("TeamColor").Value
local Money = script.Parent.CurrencyToCollect
local Debris = game:GetService('Debris')
local SoundEffects = require(game.ServerScriptService.Utility.SoundEffects)
local PressButton = game:GetService("ReplicatedStorage").Events.Tycoon.PressButton
local Purchases = game.ReplicatedStorage:WaitForChild("TycoonPurchases")
local PlayerStatManager = require(game.ServerScriptService:FindFirstChild("PlayerStatManager"))
local PlayerData = game.ServerStorage:FindFirstChild("PlayerData")
local Utility = require(game.ServerScriptService:WaitForChild("Utility"))
local UpdateInventory = game.ReplicatedStorage.Events.GUI:FindFirstChild("UpdateInventory")

script.Parent.Essentials.Spawn.TeamColor = TeamColor
script.Parent.Essentials.Spawn.BrickColor = TeamColor

local function PlaySound(part,id)
	if part:FindFirstChild("Sound") then
		return
	else
		local sound = Instance.new("Sound",part)
		sound.SoundId = "rbxassetid://"..tostring(id)
		sound:Play()
		delay(sound.TimeLength, function()
			sound:Destroy()
		end)
		--SoundService:PlayLocalSound(sound)
	end
end

local function CheckDependencies(Dependencies)
	local CompletedDependencies = 0
	local PurchasedObjects = script.Parent.PurchasedObjects
	--local DependencyAmount = Dependencies:GetChildren()
	for i,v in pairs (Dependencies:GetChildren()) do
		if PurchasedObjects:FindFirstChild(tostring(v.Value)) then
			CompletedDependencies = CompletedDependencies + 1
		end
	end
	
	return CompletedDependencies
end

local function HandleDropMaterials(Drop)
	local Tycoon = script.Parent
	local Player = Tycoon:FindFirstChild("Owner").Value
	if Drop:FindFirstChild("Materials") then
		for i,file in pairs (Drop.Materials:GetChildren()) do
			for i,material in pairs (file:GetChildren()) do
				PlayerStatManager:ChangeStat(Player, "TycoonStorage" .. tostring(material), material.Value, "TycoonStorage")
				
				PlayerStatManager:ChangeStat(Player,tostring(material) .. "Discovered", true, tostring(file))
			end
		end
	end
end

--Maybe have tycoon drop storage for every tycoon? (easier to manage)
--DropCollector Processing, Checks Current Terminal Amount Cap
for i,v in pairs(script.Parent.Essentials:GetChildren()) do 
	if v.Name == "DropCollector" then 
		v.Touched:connect(function(Part)
			if Part:FindFirstChild("Cash") then
				HandleDropMaterials(Part)
				local TerminalLevels = script.Parent.Essentials.TerminalLevel:GetChildren()
				if #TerminalLevels == 1 then --Can make this more efficient, value check for <=
					if Part.Cash.Value + Money.Value <= 100 then
						Money.Value = Money.Value + Part.Cash.Value
						Debris:AddItem(Part,0.1)
					else
						Debris:AddItem(Part,0.1)
					end
				end
				if #TerminalLevels == 2 then
					if Part.Cash.Value + Money.Value <= 200 then
						Money.Value = Money.Value + Part.Cash.Value
						Debris:AddItem(Part,0.1)
					else
						Debris:AddItem(Part,0.1)
					end
				end
			end
		end)
	end
end

--Get Money From Collector
coroutine.resume(coroutine.create(function()
	local Givers = script.Parent.Essentials:WaitForChild("Givers")
	if Givers:WaitForChild("Giver") ~= nil then
		local loop = true
		while loop == true do --checks for amount of givers, way to make more efficient?
			wait(1)
			--attempt to index nil with WaitForChild
			for i,v in pairs(Givers:GetChildren()) do
			debounce = false
				v.Touched:connect(function(hit)
					local player = game.Players:GetPlayerFromCharacter(hit.Parent)
					if player ~= nil then
						if script.Parent.Owner.Value == player then
							if hit.Parent:FindFirstChild("Humanoid") then
								if hit.Parent.Humanoid.Health > 0 then
									if debounce == false then
										debounce = true 
										v.BrickColor = BrickColor.new("Bright red")
										local PlayerDataFile = PlayerData:FindFirstChild(tostring(player.UserId))
										local Cash = PlayerDataFile:FindFirstChild("Currency")
										if Cash ~= nil then 
											local ListedPlayer = game.Players:FindFirstChild(tostring(player))
											if ListedPlayer ~= nil then
												PlaySound(v, SoundEffects.Tycoon.Collect) 
												Cash.Value = Cash.Value + Money.Value 
												
												Utility:UpdateMoneyDisplay(hit.Parent.Name, Cash.Value)
												if Money.Value ~= 0 then
													UpdateInventory:FireClient(player, "Money", nil, nil, Money.Value, "Inventory", "Money1")
												end	
													
												Money.Value = 0 
												wait(1)
												v.BrickColor = BrickColor.new("Sea green")
												debounce = false 
											else
												print("Breaking Giver Loop for " .. tostring(player))
												loop = false
											end
										end
									end
								end
							end
						end
					end
				end)
			end
		end	
	end
end))

local function PrepButton(Button, Parts)
	Button:WaitForChild("Visible").Value = true
	for bp = 1,#Parts,1 do
		Parts[bp].Transparency = 0
		Button.CanCollide = true
	end
end

local function GetPlayer(WantedPlayer)
	local Players = game.Players:GetChildren()
	for i,v in pairs(Players) do
		if tostring(v.UserId) == WantedPlayer then
			return v
		else
			warn("Something went wrong, cannot find player")
		end
	end
end

local function CheckMaterialCosts(Inventory, Button)
	local AllMaterialsCount = 0
	local AffordabilityCount = 0
	if Button:FindFirstChild("MaterialPrice") then
		local DataGroups = Button.MaterialPrice:GetChildren()
		for i,group in pairs (DataGroups) do
			local currentGroup = Inventory:FindFirstChild(tostring(group))
			for i,material in pairs (group:GetChildren()) do
				AllMaterialsCount = AllMaterialsCount + 1
				local cost = material.Value
				if currentGroup:FindFirstChild(tostring(material)).Value >= cost then
					AffordabilityCount = AffordabilityCount + 1
				end
			end
		end
		
		if AllMaterialsCount == AffordabilityCount then
			return true
		else
			return false
		end
	else
		return nil
	end	
end

--Tycoon Purchase Function
function Purchase(Table, Material)
	local cost = Table[1]
	local item = Table[2]
	local stat = Table[3] 
	
	local Player = GetPlayer(stat.Parent.Name)
	
	if Material then
		local Menu = Material.Parent
		--print(cost) --5
		--print(item) --Terminal1
		--print(stat) --Inventory
		
		for i,menu in pairs (stat:GetChildren()) do
			if menu == stat:FindFirstChild(tostring(Menu)) then
				for i,v in pairs(menu:GetChildren()) do
					if v.Name == tostring(Material) then
						print(tostring(v) .. "'s value has been subtracted by " .. tostring(cost))
						v.Value = v.Value - cost
						--UpdateInventory:FireClient(Player, tostring(v), tostring(menu), v.Value, -cost, tostring(stat))
						
						PlayerStatManager:ChangeStat(Player, v.Name, -cost, tostring(stat), true)
						--PlayerStatManager is updated here because mats only updated when "harvested" otherwise
					end
				end
			end
		end	
	else
		stat.Value = stat.Value - cost
		Utility:UpdateMoneyDisplay(Player, stat.Value)
		UpdateInventory:FireClient(Player, "Money", nil, nil, -cost, "Inventory", "Money1")
	end
	
	--Objects[item.Object.Value] is created in for _,v in pairs (script.Parent.Buttons:GetChildren())
	--Position Replicated Storage Object Clone to true position
	if Objects[item.Object.Value]:FindFirstChild("Root") ~= nil then
		local MovedModel = Objects[item.Object.Value]
		MovedModel.PrimaryPart = MovedModel.Root

		local ModelPosition = item:FindFirstChild("PrimaryPartPosition")
		MovedModel.PrimaryPart.Orientation = ModelPosition.Orientation
		MovedModel:SetPrimaryPartCFrame(CFrame.new(ModelPosition.Position))
	
		item.PrimaryPartPosition:Destroy()
		MovedModel.PrimaryPart:Destroy()
	end
	
	if script.Parent.PurchasedObjects:FindFirstChild(tostring(Objects[item.Object.Value])) == nil then
		--Shouldn't I clone it, does it get rid of it from file?
		Objects[item.Object.Value].Parent = script.Parent.PurchasedObjects
	end
	
	if item.Visible.Value == true then	
		local ButtonParts = item.Model:GetChildren()
		item.Visible.Value = false
		for bp = 1,#ButtonParts,1 do
			ButtonParts[bp].Transparency = 1
			item.CanCollide = false
		end
	end
end

script.Parent:WaitForChild("Buttons")

for _,v in pairs(script.Parent.Buttons:GetChildren()) do
	spawn(function()

		local ButtonParts = v.Model:GetChildren()
		if v:FindFirstChild("Object") then 
			local Purchases = game.ReplicatedStorage:FindFirstChild("TycoonPurchases")
			local ButtonType = v:WaitForChild("Type").Value
			local Object
			if Purchases:FindFirstChild(tostring(ButtonType)) then
				local TypeFile = Purchases:FindFirstChild(tostring(ButtonType))
				Object = TypeFile:FindFirstChild(tostring(v.Object.Value))
			else
				Object = Purchases:FindFirstChild(v.Object.Value)
			end
			if Object ~= nil then --If object affiliated is in the purchases group
				Objects[Object.Name] = Object:Clone()
				--Object:Destroy() --All objects are stored in a table, not bought = destroyed until bought
				--print(tostring(Object).." was destroyed")
			else
				error("Button "..tostring(v).." doesn't have a valid object!")
			end
			
			if v:FindFirstChild("Dependencies") then
				v.CanCollide = false
				v:WaitForChild("Visible").Value = false
				for bp = 1,#ButtonParts,1 do
					ButtonParts[bp].Transparency = 1
				end
				coroutine.resume(coroutine.create(function()
					local repeating = true
					while repeating do
						wait(3)
						local Dependencies = v.Dependencies
						local DependencyAmount = v.Dependencies:GetChildren()
						
						local FulfilledDependencies = CheckDependencies(Dependencies)
						if FulfilledDependencies == #DependencyAmount then
							repeating = false
							PrepButton(v,ButtonParts)
						end
					end
				end))
			else
				v:WaitForChild("Visible").Value = true --WaitForChild is there for now, not all buttons have it yet
			end
			
			PressButton.OnServerEvent:Connect(function(player, target)
				if target.CanCollide == true then
					if player ~= nil then
						if script.Parent.Owner.Value == player then
							
							local PlayerDataFile = PlayerData:FindFirstChild(tostring(player.UserId))
							if PlayerDataFile ~= nil then 
								local PlayerCash = PlayerDataFile:FindFirstChild("Currency")
								local PlayerInventory = PlayerDataFile:FindFirstChild("Inventory")
								local MaterialCostCheck = CheckMaterialCosts(PlayerInventory, target)
								
								--If it's a gamepass button
								if (v:FindFirstChild('Gamepass')) and (v.Gamepass.Value >= 1) then
									if game:GetService("MarketplaceService"):PlayerOwnsAsset(player,v.Gamepass.Value) then
										Purchase({[1] = v.Price.Value,[2] = v,[3] = PlayerCash})
									else
										game:GetService('MarketplaceService'):PromptPurchase(player,v.Gamepass.Value)
									end
										
								--If it's a devproduct button
								elseif (v:FindFirstChild('DevProduct')) and (v.DevProduct.Value >= 1) then
									game:GetService('MarketplaceService'):PromptProductPurchase(player,v.DevProduct.Value)
											
								--Normal Button, player can afford it
								elseif PlayerCash.Value >= target.Price.Value and MaterialCostCheck == nil then
									Purchase({[1] = target.Price.Value,[2] = target,[3] = PlayerCash})
									PlaySound(target, SoundEffects.Tycoon.Purchase)
									
								elseif PlayerCash.Value >= target.Price.Value and MaterialCostCheck == true then
									local DataGroups = target.MaterialPrice:GetChildren()
									for i,group in pairs (DataGroups) do
										local currentGroup = PlayerInventory:FindFirstChild(tostring(group))
										for i,material in pairs (group:GetChildren()) do
											local cost = material.Value
											Purchase({[1] = cost, [2] = target, [3] = PlayerInventory}, material)
											wait(.51) --Delay between purchases to successfully stack material popups
											
										end
									end
									Purchase({[1] = target.Price.Value,[2] = target,[3] = PlayerCash})
									PlaySound(target, SoundEffects.Tycoon.Purchase)
									
									
									--put another for only materials required to purchase "buttons"
									--Make more efficient, remove elseifs or decrease the amount of elseifs
									
								--If the player can't afford it
								else
									print("Cannot afford")
									local CashWarning = game.Players:FindFirstChild(tostring(player)).PlayerGui.ButtonHandler.Menu.CashWarning
									CashWarning.Visible = true
									PlaySound(v, SoundEffects.Tycoon.ErrorBuy)
									wait(2)
									CashWarning.Visible = false
								end
							else
								print("This player doesn't have an affiliated DataStore")
							end
						end
					end
				end
			end)
		end
	end)
end
	
return Objects