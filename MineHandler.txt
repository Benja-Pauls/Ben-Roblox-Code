(Script)
Handles mining, mine generation, and ore generation after ore is mined (generates a new block around mined block that were previously nothing)

Most Recent Update (11/11/2020): Regions now can spawn "structures" growing off the ground and hanging from the ceiling, along with some other code tweaks.
------------------------------------------------------------------------------------------------------------------------------------------------

local PlayerStatManager = require(game.ServerScriptService:WaitForChild("PlayerStatManager"))
local OriginalOres = game.ReplicatedStorage.Ores:GetChildren()
local OriginalRegions = game.ReplicatedStorage.MineRegions:GetChildren()
local PlayerData = game:GetService("ServerStorage"):WaitForChild("PlayerData")
local TeleportButton = game:GetService("ReplicatedStorage").Events.GUI:WaitForChild("TeleportButton")


local function FillObjectTables(Original, IsA, Table) --Folder Read Setup
	for index,Object in pairs(Original) do
		if Object:IsA(IsA) or Object:IsA("Model") then --Chang model to IsA2 or IsaExtra?
			table.insert(Table,Object)
		end
	end
end

local Ores = {}
local Regions = {}

FillObjectTables(OriginalOres, "BasePart", Ores)
FillObjectTables(OriginalRegions, "Folder", Regions)


local function GetObjectFromId(Object,Id)
	return Object[Id]
end

local function InsertIntoTable(Chance, Table, Index) --Put into Utility script
	for i=1,Chance do
		table.insert(Table,Index)
	end
end


local UsedPositions = {} --Check if position is taken up by block

local function PositionKey(x,y,z)
	return x..","..y..","..z
end

TeleportButton.OnServerEvent:Connect(function(player, button)
	local PlayersFolder = workspace:FindFirstChild("Players")
	if PlayersFolder:FindFirstChild(tostring(player)) ~= nil then
		if button.Name == "ToSurfaceButton" then
			local Player = PlayersFolder:FindFirstChild(tostring(player))
			Player.LowerTorso.CFrame = workspace.SpawnLocation.CFrame
		end
	end
end)

local function CalculateChance(y,Selection)
	local MaxDepth, MinDepth = (Selection.MaxDepth.Value > 0 and Selection.MaxDepth.Value) or 9999, (Selection.MinDepth.Value > 0 and Selection.MinDepth.Value) or 1
	local Range = MaxDepth - MinDepth + 1
	local MinDistance = y - MinDepth + 1
	local MaxDistance = MaxDepth - y + 1
	local MaxRarity, MinRarity = Selection.MaxRarity.Value, Selection.MinRarity.Value

	--math.ceil means round up
	local Chance = math.ceil(((MinDistance/Range) * MinRarity + (MaxDistance/Range) * MaxRarity) / 2)
	if y >= MinDepth and y <= MaxDepth then
		return Chance
	end
end

local function DecideSelection(y, Table, RegionSpecific)
	
	local Lottery = {}
	
	--Way to include both? Where the region specific ores have a much higher chance? Or keep "specialty" of regions?
	for Index,Selection in pairs(Table) do --Has to work with region calculation
		if not Selection:FindFirstChild("SpecialStructure") then
			local Chance = CalculateChance(y,Selection)
			--print(Chance)
			if Chance ~= nil then
				if not RegionSpecific or tostring(RegionSpecific) == "true" then
					if not Selection:FindFirstChild("RegionSpecial") then
						InsertIntoTable(Chance,Lottery,Index)
					end
				elseif RegionSpecific then
					if Selection:FindFirstChild("RegionSpecial") then
						if Selection.RegionSpecial.Value == tostring(RegionSpecific) then
							InsertIntoTable(Chance,Lottery,Index)
						end
					elseif not Selection:FindFirstChild("RegionSpecial") then
						if Selection.Name ~= "Stone" then
							Chance = Chance/50
						end
						InsertIntoTable(Chance,Lottery,Index)
					end
				end
					
				--[[ (Older only region specific ores script)
				elseif tostring(Selection) == "Stone" then
					for i=1,Chance do
						table.insert(Lottery,Index)
					end
				else --managing region specific ores
					if not Selection:FindFirstChild("SpecialStructure") and Selection:FindFirstChild("RegionSpecial") then
						if Selection.RegionSpecial.Value == tostring(RegionSpecific) then
		
							for i=1,Chance do
								table.insert(Lottery,Index)
							end
						end
					end
				end
				]]
					
			end
		end
	end
	
	local Id = Lottery[math.random(1,#Lottery)]
	
	--print(GetObjectFromId(Table,Id))
	
	return GetObjectFromId(Table,Id)
end

local function SpawnStructures(x,y,z,Bounds,Region)
	for Index,Selection in pairs (game.ReplicatedStorage.Ores:GetChildren()) do
		if Selection:FindFirstChild("SpecialStructure") and Selection:FindFirstChild("RegionSpecial").Value == tostring(Region) then
			if Selection.SpecialStructure.Value == tostring(Bounds) then
				
				local SpawnChance = math.random(1,50)--change so this goes along with their personal rarity calculation

				if SpawnChance >= 48 then 

					local Structure = Selection:Clone()
					
					Structure.Parent = workspace.Mine
					Structure.CFrame = CFrame.new(0+x*7, -5+y*(-7), 0+z*7)
					
					if Structure:FindFirstChild("MeshPart") then
						Structure.MeshPart.CFrame = CFrame.new(0+x*7, -5+y*(-7), 0+z*7)
						
						if Structure.MeshPart:FindFirstChild("Offset") then
							local Offset = Structure.MeshPart.Offset.Value
							Structure.MeshPart.Position = Structure.MeshPart.Position + Vector3.new(0,Offset.Y,0)
						end
					end
					
					UsedPositions[PositionKey(x,y,z)] = Structure
					
				end
			end
		end
	end
end

--Immediate blocks around 0,0,0 (cave/region generation pattern)
local VectorsGen = {
	Vector3.new(-1,0,0),
	Vector3.new(1,0,0),
	Vector3.new(0,-1,0),	
	Vector3.new(0,1,0),
	Vector3.new(0,0,1),
	Vector3.new(0,0,-1)
}

--Blocks around and prepping below with widened top (mining pattern)
local VectorsMine = {
	Vector3.new(-1,0,0),
	Vector3.new(1,0,0),
	Vector3.new(0,-1,0),
	Vector3.new(0,1,0),
	Vector3.new(0,0,1),
	Vector3.new(0,0,-1),
	Vector3.new(0,2,0),
	Vector3.new(-1,0,-1),
	Vector3.new(1,0,1),
	Vector3.new(-1,0,1),
	Vector3.new(1,0,-1)
}

local GCounts = {} --Amount of blocks in generation array

local CurrentGeneratingRegion
function GenerateOre(x,y,z,Override,PresetPoint,Region)
	if (UsedPositions[PositionKey(x,y,z)] == nil or Override == true) and y > 0 then
		
		local Noise = math.noise(x/25,y/15,z/25) --math.noise is a perlin noise calculator, #'s are near each other, hence ability to make "natural" caves
		--print(Noise)
		--print(tostring(250 % 4)) --% means modulo, or finding the remainder of division between the first & second #
		local CompactPos = Vector3.new(x,y,z)
		
		--Cave Generation (generates until all blocks are filled, including VectorsGen nearby blocks
		if y > 2 and ((Noise >= 0.48) or (Noise <= -0.48)) then --.525?
			
			UsedPositions[PositionKey(x,y,z)] = false
			
			if Override ~= "Branch" then
				
				local Origin = PositionKey(x,y,z)
				GCounts[Origin] = 0 --Creating table with name of origin, definitive non-changing distinguishable point
				
				local Region = DecideSelection(y,Regions)
				GCounts[Region] = Region
				print("REGION: " .. tostring(GCounts[Region]))
				
				--For setting the cave apart from just a cave, maybe a closer to zero noise value will be used to generate nearby solids?
				
				coroutine.resume(coroutine.create(function()
					for i,Vec in pairs(VectorsGen) do
						local NewPos = CompactPos + Vec

						if UsedPositions[PositionKey(NewPos.x,NewPos.y,NewPos.z)] == nil then 
							GCounts[Origin] = GCounts[Origin] + 1
							GenerateOre(NewPos.x,NewPos.y,NewPos.z,"Branch",Origin,Region)
							--Branch will start actual cave generation, checking Noise everytime
							--Noise correlates to natural shape

						end
					end
				end))
				
			else
				--print("Cave is generating!")
				local Origin = PresetPoint --Assigned as Origin from non-branch if statement
				
				--Special structure bounds
				local BelowNoise = math.noise(x/25, (y+1)/15, z/25)
				local BlockBelow = not (BelowNoise >= 0.48 or BelowNoise <= -0.48)
				
				local AboveNoise = math.noise(x/25, (y-1)/15, z/25)
				local BlockAbove = not (AboveNoise >= 0.48 or AboveNoise <= -0.48)		
				--if BlockAbove or (y-1)<3 then --2 check in case ceiling is top level of stone
					--print("OHHHH: " .. tostring(AboveNoise),y)
				--end
				
				--Particular block stuructres, not air or walls (make function later with more criteria)
				if BlockBelow or BlockAbove or (y-1)<3 then
					local Bounds
					if BlockBelow then --Way to make more efficient?? Especially with more bounds later?
						Bounds = "BlockBelow"
					elseif BlockAbove or (y-1)<3 then
						Bounds = "BlockAbove"
						print(BlockAbove)
					end
					SpawnStructures(x,y,z,Bounds,Region)
				end 
				
				for i,Vec in pairs(VectorsGen) do
					local NewPos = CompactPos + Vec
					if UsedPositions[PositionKey(NewPos.x,NewPos.y,NewPos.z)] == nil then
						GCounts[Origin] = GCounts[Origin] + 1
						if GCounts[Origin] % 250 == 0 then --Wait every 100
							wait()
						end
						--print(GCounts[Origin])
						GenerateOre(NewPos.x,NewPos.y,NewPos.z,"Branch",Origin,Region)
					end
				end	
			end
			
			--Why does color revert back to "stock" when you finish region generation? That's good
			--that it is happening, but why?
			
		else
			local Ore = DecideSelection(y,Ores,Region):Clone()
			--Ore = DecideOre(y,(Override == "Branch")):Clone()

			for i,v in pairs(Ore:GetChildren()) do --Makes spawns more efficient
				if v:IsA("StringValue") or v:IsA("NumberValue") or v:IsA("Color3Value") or v:IsA("IntValue") or v:IsA("Folder") then
					v:Destroy()
				end
			end
			
			if GCounts[Region] ~= nil then
				local RegionColor = GCounts[Region]:FindFirstChild("BlockColor").Value
				Ore.Color = RegionColor
				
				local AmbientLighting = Instance.new("PointLight",Ore)
				AmbientLighting.Color = RegionColor
				
				if RegionColor.R + RegionColor.G + RegionColor.B <= 250 then
					AmbientLighting.Brightness = 3.5
				end
				
				if tostring(GCounts[Region]) == "Normal" then
					AmbientLighting.Brightness = 0.5
					AmbientLighting.Range = 5
				end
			end

			Ore.Parent = workspace.Mine
			Ore.CFrame = CFrame.new(0+x*7, -5+y*(-7), 0+z*7)
			--Ore.Transparency = math.abs(1*Noise)
			UsedPositions[PositionKey(x,y,z)] = Ore
			return Ore
		end
	end		
end

--[[
local function DestroyOre(Ore)
	
	local Hitbox = Ore
	
	local CompactPos = Vector3.new(0 + Hitbox.Position.X/7,(Hitbox.Position.Y - -5)/(-7),Hitbox.Position.Z/7)
	
	UsedPositions[PositionKey(CompactPos.X,CompactPos.Y,CompactPos.Z)] = false
	
	if Ore.IsA("BasePart") and Ore:FindFirstChild("AntiGen") == nil and Ore.Anchored then
		for i,Vector in pairs(VectorsMine) do
			local NewPos = CompactPos + Vector
			if UsedPositions[PositionKey(NewPos.x,NewPos.y,NewPos.z)] == nil then
				
				GenerateOre(NewPos.x,NewPos.y,NewPos.z,false,nil,nil,nil)
			end
		end
	end
	Ore:Destroy() --Destroy Ore after all has been prepared
end
]]

function game.ServerStorage.MineOre.OnInvoke(Player,Ore)
	local RealOre = game.ReplicatedStorage.Ores:FindFirstChild(Ore.Name)
	if Ore:FindFirstChild("Claimed") == nil then
		
		local Hitbox = Ore
		local CompactPos = Vector3.new(0 + Hitbox.Position.X/7,(Hitbox.Position.Y - -5)/(-7),Hitbox.Position.Z/7)
		
		UsedPositions[PositionKey(CompactPos.X,CompactPos.Y,CompactPos.Z)] = false
		
		for i,Vector in pairs(VectorsMine) do
			local NewPos = CompactPos + Vector
			if UsedPositions[PositionKey(NewPos.x,NewPos.y,NewPos.z)] == nil then
				GenerateOre(NewPos.x,NewPos.y,NewPos.z,false,nil,nil,nil)
			end
		end
		
		--Add Ore to inventory
		local mined = PlayerStatManager:getStat(Player, Ore.Name)
		local experience = PlayerStatManager:getStat(Player, "MiningSkill")
		print(typeof(mined),typeof(experience))
		if typeof(mined) == "number" and typeof(experience) == "number" then
			PlayerStatManager:ChangeStat(Player, Ore.Name, 1, "Inventory", true)
			
			local InitialOreExperience = RealOre.Experience.Value
			PlayerStatManager:ChangeStat(Player, "MiningSkill", InitialOreExperience, "Experience", true)
			
			local PlayerDataFile = PlayerData:WaitForChild(tostring(Player.UserId))
			local PlayerInventory = PlayerDataFile:WaitForChild("Inventory")
			local PlayerExperience = PlayerDataFile:WaitForChild("Experience")
			local OresFolder = PlayerInventory:WaitForChild("Ores")
			local SkillsFolder = PlayerExperience:WaitForChild("Skills")
			
			local CurrentOre = OresFolder:FindFirstChild(Ore.Name)
			CurrentOre.Value = CurrentOre.Value + 1
			
			local CurrentSkill = SkillsFolder:FindFirstChild("MiningSkill")
			CurrentSkill.Value = CurrentSkill.Value + InitialOreExperience
			
			--Change player discovered value if this is first time acquired
			local DiscoverValue = CurrentOre:FindFirstChild(tostring(Ore) .. "Discovered")
			if DiscoverValue.Value == false then
				print("Changing " .. tostring(DiscoverValue) .. " to true")
				DiscoverValue.Value = true
				PlayerStatManager:ChangeStat(Player, tostring(Ore) .. "Discovered", true, tostring(OresFolder))
			end
		else
			warn("mined or experience cannot be saved")
		end
		Ore:Destroy()
	end
end

local function GenerateMine()
	print("Generating Mine")
	
	workspace.Regen.Transparency = 0
	workspace.Regen.CanCollide = true
	workspace.Regen.CFrame = CFrame.new(355, -10, 11)
	
	for i,Player in pairs(workspace.Players:GetChildren()) do
		if Player:FindFirstChild("LowerTorso") then
			local RawPosition = Player.LowerTorso.Position
			local CompactPos = Vector3.new(0 + RawPosition.X/7,(RawPosition.Y - -5)/(-7),RawPosition.Z/7)
			if math.floor(CompactPos.X) > 0 and -math.floor(CompactPos.Y) < 10 and math.floor(CompactPos.Z) > 0 then
				Player.LowerTorso.CFrame = workspace.SpawnLocation.CFrame
			end
		end
	end
	
	local count = 1
	for i,Ore in pairs(workspace.Mine:GetChildren()) do
		Ore:Destroy()
		count = count + 1
		if count > 50 then
			count = 1
			wait()
		end
	end
	
	UsedPositions = {} --Reset Table
	for x=1,27 do
		for z=1,27 do
			GenerateOre(x,1,z,false,nil,true)
		end
	end
	
	wait(1)
	
	workspace.Regen.Transparency = 1
	workspace.Regen.CanCollide = false
	workspace.Regen.CFrame = CFrame.new(355, 10, 11)
	
	repeat wait(10) until #workspace.Mine:GetChildren() > 5000
	print(tostring(#workspace.Mine:GetChildren()) .. ";consequently, mine is resetting")
	GenerateMine()
end

GenerateMine()





