(Script)
Handles mining, mine generation, and ore generation after ore is mined (generates a new block around mined block that were previously nothing)

------------------------------------------------------------------------------------------------------------------------------------------------

local PlayerStatManager = require(game.ServerScriptService:WaitForChild("PlayerStatManager"))
local OriginalOres = game.ReplicatedStorage.Ores:GetChildren()
local OriginalRegions = game.ReplicatedStorage.MineRegions:GetChildren()
local PlayerData = game:GetService("ServerStorage"):WaitForChild("PlayerData")
local TeleportButton = game:GetService("ReplicatedStorage").Events.GUI:WaitForChild("TeleportButton")


local function FillObjectTables(Original, IsA, Table) --Folder Read Setup
	for index,Object in pairs(Original) do
		if Object:IsA(IsA) or Object:IsA("Model") then --Chang model to IsA2 or IsaExtra?
			table.insert(Table,Object)
		end
	end
end

local Ores = {}
local Regions = {}

FillObjectTables(OriginalOres, "BasePart", Ores)
FillObjectTables(OriginalRegions, "Folder", Regions)


local function GetObjectFromId(Object,Id)
	return Object[Id]
end

local function InsertIntoTable(Chance, Table, Index) --Put into Utility script
	for i=1,Chance do
		table.insert(Table,Index)
	end
end

--local SeedChange (multiply z by this later, changed for each cave generation so caves don't repeat)
local function CalculateNoise(x,y,z)
	--Special structure bounds
	local BelowNoise = math.noise(x/25, (y+1)/15, z/25)
	local BlockBelow = not (BelowNoise >= 0.48 or BelowNoise <= -0.48)

	local AboveNoise = math.noise(x/25, (y-1)/15, z/25)
	local BlockAbove = not (AboveNoise >= 0.48 or AboveNoise <= -0.48)
	
	return BlockBelow,BlockAbove	
end

local UsedPositions = {} --Used cave block positions table

local function PositionKey(x,y,z)
	return x..","..y..","..z
end

TeleportButton.OnServerEvent:Connect(function(player, button)
	local PlayersFolder = workspace:FindFirstChild("Players")
	if PlayersFolder:FindFirstChild(tostring(player)) ~= nil then
		if button.Name == "ToSurfaceButton" then
			local Player = PlayersFolder:FindFirstChild(tostring(player))
			Player.LowerTorso.CFrame = workspace.SpawnLocation.CFrame
		end
	end
end)

local function CalculateChance(y,Selection)
	local MaxDepth, MinDepth = (Selection.MaxDepth.Value > 0 and Selection.MaxDepth.Value) or 9999, (Selection.MinDepth.Value > 0 and Selection.MinDepth.Value) or 1
	local Range = MaxDepth - MinDepth + 1
	local MinDistance = y - MinDepth + 1
	local MaxDistance = MaxDepth - y + 1
	local MaxRarity, MinRarity = Selection.MaxRarity.Value, Selection.MinRarity.Value

	--math.ceil means round up
	local Chance = math.ceil(((MinDistance/Range) * MinRarity + (MaxDistance/Range) * MaxRarity) / 2)
	if y >= MinDepth and y <= MaxDepth then
		return Chance
	end
end

local function DecideSelection(y, Table, RegionSpecific)
	
	local Lottery = {}
	
	for Index,Selection in pairs(Table) do
		if not Selection:FindFirstChild("SpecialStructure") then
			local Chance = CalculateChance(y,Selection)

			if Chance ~= nil then
				if not RegionSpecific or tostring(RegionSpecific) == "true" then
					if not Selection:FindFirstChild("RegionSpecial") then
						InsertIntoTable(Chance,Lottery,Index)
					end
				elseif RegionSpecific then
					if Selection:FindFirstChild("RegionSpecial") then
						if Selection.RegionSpecial.Value == tostring(RegionSpecific) then
							InsertIntoTable(Chance,Lottery,Index)
						end
					elseif not Selection:FindFirstChild("RegionSpecial") then
						if Selection.Name ~= "Stone" then
							Chance = math.ceil(Chance/50)
						end
						InsertIntoTable(Chance,Lottery,Index)
					end
				end				
			end
		end
	end
	
	local Id = Lottery[math.random(1,#Lottery)]
	
	--print(GetObjectFromId(Table,Id))
	
	return GetObjectFromId(Table,Id)
end

local function SpawnStructures(x,y,z,Bounds,Region)
	
	local Lottery = {}
	
	for Index,Selection in pairs (game.ReplicatedStorage.Ores:GetChildren()) do
		if Selection:FindFirstChild("SpecialStructure") and Selection:FindFirstChild("RegionSpecial").Value == tostring(Region) then
			if Selection.SpecialStructure.Value == tostring(Bounds) then
				local Chance = CalculateChance(y,Selection)
				InsertIntoTable(Chance,Lottery,Index)
			end
		end
	end
	
	if #Lottery > 0 then
		local Id = Lottery[math.random(1,#Lottery)]
		local FinalSelection = GetObjectFromId(Ores,Id)
					
		local SpawnChance = math.random(1,FinalSelection.MaxRarity.Value)

		if SpawnChance <= FinalSelection.MaxRarity.Value/FinalSelection["1/SpawnChance"].Value then 
			local Structure = FinalSelection:Clone()

			Structure.Parent = workspace.Mine
			Structure.CFrame = CFrame.new(0+x*7, -5+y*(-7), 0+z*7)

			if Structure:FindFirstChild("MeshPart") then
				Structure.MeshPart.CFrame = CFrame.new(0+x*7, -5+y*(-7), 0+z*7)

				--Variance in strucutre spawns
				local RotationRandom = math.random(1,4)
				Structure.MeshPart.Rotation = Vector3.new(0, 90*RotationRandom, 0)
				if Structure.MeshPart:FindFirstChild("Offset") then
					local Offset = Structure.MeshPart.Offset.Value
					Structure.MeshPart.Position = Structure.MeshPart.Position + Vector3.new(0,Offset.Y,0)
				end
			end
			UsedPositions[PositionKey(x,y,z)] = Structure
		end
	end
end

--Immediate blocks around 0,0,0 (cave/region generation pattern)
local VectorsGen = {
	Vector3.new(-1,0,0),
	Vector3.new(1,0,0),
	Vector3.new(0,-1,0),	
	Vector3.new(0,1,0),
	Vector3.new(0,0,1),
	Vector3.new(0,0,-1)
}

--Blocks around and prepping below with widened top (mining pattern)
local VectorsMine = {
	Vector3.new(-1,0,0),
	Vector3.new(1,0,0),
	Vector3.new(0,-1,0),
	Vector3.new(0,1,0),
	Vector3.new(0,0,1),
	Vector3.new(0,0,-1),
	Vector3.new(0,2,0),
	Vector3.new(-1,0,-1),
	Vector3.new(1,0,1),
	Vector3.new(-1,0,1),
	Vector3.new(1,0,-1)
}

local GCounts = {} --Amount of blocks in generation array

local ExclaimRegion = game.ReplicatedStorage.Events.GUI.ExclaimRegion
local HighestYValue = 0
function GenerateOre(x,y,z,Override,PresetPoint,Region,Player)
	if (UsedPositions[PositionKey(x,y,z)] == nil or Override == true) and y > 0 then
		
		local Noise = math.noise(x/25,y/15,z/25) --math.noise is a perlin noise calculator, #'s are near each other, hence ability to make "natural" caves
		--print(Noise)
		--print(tostring(250 % 4)) --% means modulo, or finding the remainder of division between the first & second #
		local CompactPos = Vector3.new(x,y,z)
		
		--Cave Generation (generates until all blocks are filled, including VectorsGen nearby blocks
		if y > 2 and ((Noise >= 0.48) or (Noise <= -0.48)) then --.525?
			
			UsedPositions[PositionKey(x,y,z)] = false
			
			if y > HighestYValue then
				HighestYValue = y
			end
			
			--Ambient air here
			--(How would this be done... random location assignment of block? Otherwise, blocks may interfere with pickaxe mining)
		
			if Override ~= "Branch" then
				HighestYValue = 0
				local Origin = PositionKey(x,y,z)
				GCounts[Origin] = 0 --Creating table with name of origin, definitive non-changing distinguishable point
				
				local Region = DecideSelection(y,Regions)
				GCounts[Region] = Region
				
				if Player then --Player is true when block is first mined
					ExclaimRegion:FireClient(Player,Region)
				end
				
				print("REGION: " .. tostring(GCounts[Region]))
				
				--For setting the cave apart from just a cave, maybe a closer to zero noise value will be used to generate nearby solids?
				
				coroutine.resume(coroutine.create(function()
					for i,Vec in pairs(VectorsGen) do
						local NewPos = CompactPos + Vec

						if UsedPositions[PositionKey(NewPos.x,NewPos.y,NewPos.z)] == nil then 
							GCounts[Origin] = GCounts[Origin] + 1
							GenerateOre(NewPos.x,NewPos.y,NewPos.z,"Branch",Origin,Region)
							--Branch will start actual cave generation, checking Noise everytime
							--Noise correlates to natural shape
						end
					end
				end))
				
				coroutine.resume(coroutine.create(function() --After the entire mine has been generated, check the true value for highy
					wait(1)
					print("The true highest value for y is " .. tostring(HighestYValue))
					
					--For liquid generation, how will it be mined? Long mine, where you mine the entire body of liquid, or individual chunks?)
				end))
				
			else
				local Origin = PresetPoint --Assigned as Origin from non-branch if statement
				
				local BlockBelow,BlockAbove = CalculateNoise(x,y,z)	
				
				--Particular block stuructres, not air or walls (make function later with more criteria)

				if BlockBelow or BlockAbove or (y-1)<3 then
					local Bounds
					if BlockBelow then --Way to make more efficient?? Especially with more bounds later?
						Bounds = "BlockBelow"
					elseif BlockAbove or (y-1)<3 then
						Bounds = "BlockAbove"
					end
					SpawnStructures(x,y,z,Bounds,Region)
				end 
				
				for i,Vec in pairs(VectorsGen) do
					local NewPos = CompactPos + Vec
					if UsedPositions[PositionKey(NewPos.x,NewPos.y,NewPos.z)] == nil then
						GCounts[Origin] = GCounts[Origin] + 1
						if GCounts[Origin] % 250 == 0 then --Wait every 100
							wait()
						end
						GenerateOre(NewPos.x,NewPos.y,NewPos.z,"Branch",Origin,Region)
					end
				end	
			end
			
			--Why does color revert back to "stock" when you finish region generation? That's good
			--that it is happening, but why?
			
		else
			local Ore = DecideSelection(y,Ores,Region):Clone()
			--Ore = DecideOre(y,(Override == "Branch")):Clone()

			for i,v in pairs(Ore:GetChildren()) do --Makes spawns more efficient
				if v:IsA("StringValue") or v:IsA("NumberValue") or v:IsA("Color3Value") or v:IsA("IntValue") or v:IsA("Folder") then
					v:Destroy()
				end
			end
			
			if GCounts[Region] ~= nil then
				local RegionColor = GCounts[Region]:FindFirstChild("BlockColor").Value
				Ore.Color = RegionColor
				
				local AmbientLighting = Instance.new("PointLight",Ore)
				AmbientLighting.Color = RegionColor
				
				if RegionColor.R + RegionColor.G + RegionColor.B <= 250 then
					AmbientLighting.Brightness = 5
					AmbientLighting.Range = 15
				end
				
				if tostring(GCounts[Region]) == "Normal" then
					AmbientLighting.Brightness = 0.5
					AmbientLighting.Range = 5
				end
			end

			Ore.Parent = workspace.Mine
			Ore.CFrame = CFrame.new(0+x*7, -5+y*(-7), 0+z*7)
			--Ore.Transparency = math.abs(1*Noise)
			UsedPositions[PositionKey(x,y,z)] = Ore
			return Ore
		end
	end		
end

--[[
local function DestroyOre(Ore)
	
	local Hitbox = Ore
	
	local CompactPos = Vector3.new(0 + Hitbox.Position.X/7,(Hitbox.Position.Y - -5)/(-7),Hitbox.Position.Z/7)
	
	UsedPositions[PositionKey(CompactPos.X,CompactPos.Y,CompactPos.Z)] = false
	
	if Ore.IsA("BasePart") and Ore:FindFirstChild("AntiGen") == nil and Ore.Anchored then
		for i,Vector in pairs(VectorsMine) do
			local NewPos = CompactPos + Vector
			if UsedPositions[PositionKey(NewPos.x,NewPos.y,NewPos.z)] == nil then
				
				GenerateOre(NewPos.x,NewPos.y,NewPos.z,false,nil,nil,nil)
			end
		end
	end
	Ore:Destroy() --Destroy Ore after all has been prepared
end
]]
--local CheckItemAmount = game.ReplicatedStorage.Events.GUI.CheckItemTypeAmount

function game.ServerStorage.MineOre.OnInvoke(Player,Ore)
	local RealOre = game.ReplicatedStorage.Ores:FindFirstChild(Ore.Name)
	local OreColor = RealOre.OreColor.Value
	
	local TypeAmount = PlayerStatManager:getStatForType(Player, "Ores")
	
	--local BagName = 
	local BagLevel --= PlayerStatManager:getStat()
	
	--This only checks the value of one item, and, since the save hasn't been updated, it is one less than the amount
	--in the player's inventory that would happen if they mined (so the current state of that item)
	
	if TypeAmount < 100 then --this will be a PSM:GetStat for the bag's max capacity
		if Ore:FindFirstChild("Claimed") == nil then
			
			local Hitbox = Ore
			local CompactPos = Vector3.new(0 + Hitbox.Position.X/7,(Hitbox.Position.Y - -5)/(-7),Hitbox.Position.Z/7)
			
			UsedPositions[PositionKey(CompactPos.X,CompactPos.Y,CompactPos.Z)] = false
			
			for i,Vector in pairs(VectorsMine) do
				local NewPos = CompactPos + Vector
				if UsedPositions[PositionKey(NewPos.x,NewPos.y,NewPos.z)] == nil then
					GenerateOre(NewPos.x,NewPos.y,NewPos.z,false,nil,nil,Player)
				end
			end
			
			local BlockBelow,BlockAbove = CalculateNoise(CompactPos.X,CompactPos.Y,CompactPos.Z)
			
			--Break connected structures
			if not BlockBelow or not BlockAbove then
				local Y
				if not BlockBelow then
					Y = CompactPos.Y+1
				else
					Y = CompactPos.Y-1
				end
				
				if UsedPositions[PositionKey(CompactPos.X,Y,CompactPos.Z)] ~= false and UsedPositions[PositionKey(CompactPos.X,Y,CompactPos.Z)] ~= nil then
					local ConnectedOre = UsedPositions[PositionKey(CompactPos.X,Y,CompactPos.Z)]
					if game.ReplicatedStorage.Ores:FindFirstChild(tostring(ConnectedOre)):FindFirstChild("SpecialStructure") then
						local OrePosition = ConnectedOre.Position
						local ConnectedOreColor = ConnectedOre.OreColor.Value
						MakeDustParticles(OrePosition,ConnectedOreColor)
						UsedPositions[PositionKey(CompactPos.X,Y,CompactPos.Z)]:Destroy()
						--game.ServerStorage.MineOre:Invoke(Player, UsedPositions[PositionKey(CompactPos.X,Y,CompactPos.Z)])
					end
				end
			end
			
			--Add Ore to inventory
			local mined = PlayerStatManager:getStat(Player, Ore.Name)
			local experience = PlayerStatManager:getStat(Player, "MiningSkill")
			--print(typeof(mined),typeof(experience))
			if typeof(mined) == "number" and typeof(experience) == "number" then
				PlayerStatManager:ChangeStat(Player, Ore.Name, 1, "Inventory", true)
				
				local InitialOreExperience = RealOre.Experience.Value
				PlayerStatManager:ChangeStat(Player, "MiningSkill", InitialOreExperience, "Experience", true)
				
				local PlayerDataFile = PlayerData:WaitForChild(tostring(Player.UserId))
				local PlayerInventory = PlayerDataFile:WaitForChild("Inventory")
				local PlayerExperience = PlayerDataFile:WaitForChild("Experience")
				local OresFolder = PlayerInventory:WaitForChild("Ores")
				local SkillsFolder = PlayerExperience:WaitForChild("Skills")
				
				local CurrentOre = OresFolder:FindFirstChild(Ore.Name)
				--CurrentOre.Value = CurrentOre.Value + 1
				
				local CurrentSkill = SkillsFolder:FindFirstChild("MiningSkill")
				--CurrentSkill.Value = CurrentSkill.Value + InitialOreExperience
				
				--Change player discovered value if this is first time acquired
				local DiscoverValue = CurrentOre:FindFirstChild(tostring(Ore) .. "Discovered")
				if DiscoverValue.Value == false then
					print("Changing " .. tostring(DiscoverValue) .. " to true")
					DiscoverValue.Value = true
					PlayerStatManager:ChangeStat(Player, tostring(Ore) .. "Discovered", true, tostring(OresFolder))
				end
			else
				warn("mined or experience cannot be saved")
			end
			
			local OrePosition = Ore.Position
			
			Ore:Destroy()
			
			MakeDustParticles(OrePosition,OreColor)
		end
	else
		--Notify player that their inventory is full and they should sell/deposit their items 
	end
end

function MakeDustParticles(OrePosition, OreColor)
	coroutine.resume(coroutine.create(function()
		local LeftoverDust = game.ReplicatedStorage.GuiElements.BlockDestroy:Clone()

		--To make the particles look less like they're coming off one source, make multiple small emitters offset from source
		LeftoverDust.Parent = workspace
		LeftoverDust.CFrame = CFrame.new(OrePosition)
		LeftoverDust.Particles.Color = ColorSequence.new(OreColor)
		LeftoverDust.Particles.Enabled = true
		wait(0.05)
		LeftoverDust.Particles.Enabled = false
		wait(0.5)
		LeftoverDust:Destroy()
	end))	
end

local function GenerateMine()
	print("Generating Mine")
	
	workspace.Regen.Transparency = 0
	workspace.Regen.CanCollide = true
	workspace.Regen.CFrame = CFrame.new(355, -10, 11)
	
	for i,Player in pairs(workspace.Players:GetChildren()) do
		if Player:FindFirstChild("LowerTorso") then
			local RawPosition = Player.LowerTorso.Position
			local CompactPos = Vector3.new(0 + RawPosition.X/7,(RawPosition.Y - -5)/(-7),RawPosition.Z/7)
			if math.floor(CompactPos.X) > 0 and -math.floor(CompactPos.Y) < 10 and math.floor(CompactPos.Z) > 0 then
				Player.LowerTorso.CFrame = workspace.SpawnLocation.CFrame
			end
		end
	end
	
	local count = 1
	for i,Ore in pairs(workspace.Mine:GetChildren()) do
		Ore:Destroy()
		count = count + 1
		if count > 50 then
			count = 1
			wait()
		end
	end
	
	UsedPositions = {} --Reset Table
	for x=1,27 do
		for z=1,27 do
			GenerateOre(x,1,z,false,nil,true)
		end
	end
	
	wait(1)
	
	workspace.Regen.Transparency = 1
	workspace.Regen.CanCollide = false
	workspace.Regen.CFrame = CFrame.new(355, 10, 11)
	
	repeat wait(10) until #workspace.Mine:GetChildren() > 5000
	print(tostring(#workspace.Mine:GetChildren()) .. ";consequently, mine is resetting")
	GenerateMine()
end

GenerateMine()
